= 代理模式

代理模式又叫委托模式，是为某个对象提供一个代理对象，并且由代理对象控制对源对象的访问。代理模式通俗来讲就是我们生活中常见的中介。 代理模式可以提供非常友好的访问控制，应用比较广泛。

== 结构

代理模式主要角色如下：

. 抽象主题(Subject)：通过接口或抽象类声明真实主题和代理主题实现业务的方法
. 真实主题(Real Subject)：实现了抽象主题中的具体业务，是代理对象所代表的的真是对象是最终要引用的对象
. 代理(Proxy)：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或拓展真实主题的功能

== 适合的应用场景

使用代理模式的方式多种多样，以下是常见的几种。

[unordered.stack]
延迟初始化（虚拟代理）::
如果有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可使用代理模式。 无需在程序启动的时候就创建该对象，可将对象的初始化延迟到真正有需要的时候。
访问控制（保护代理）::
如果只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，而客户端则是各种已启动的程序（包括恶意程序），此时可以使用代理模式。 代理可仅在客户端凭据满足要求时将请求传递给服务对象。
本地执行远程服务（远程代理）::
适用于服务对象位于远程服务器的情形。在这种情形中，代理通过网络传递客户端请求，负责处理所有与网络相关的复杂细节。
记录日志请求（日志记录代理）::
适用于需要保存对于服务请求对象的请求历史纪录是。代理可以在向服务传递请求前进行记录。
缓存请求结果（缓存代理）::
适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是当返回结果的体积特别大时。 代理可以对重复请求所需的相同结果进行缓存，还可以使用请求参数座位索引缓存的键值。
智能引用::
可在没有客户端使用的某个重量级对象时立即销毁该对象。代理会将所有获取了服务对象或其结果的客户端记录在案。代理会时不时地遍历各个客户端，检查它们是否仍在运行。
如果相应的客户端列表为空，代理就会销毁该服务对象，释放底层系统资源。代理还可以记录客户端是否修改了服务对象。其他客户端还可以复用未修改的对象。

=== 实现方式

. 创建一个接口来实现代理和服务对象的可交换性
. 创建代理类，其中必须包含一个存储指向服务的引用的成员变量
. 根据需求实现代理方法
. 可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务
. 可以考虑为服务对象实现延迟初始化

代理模式有多种不同的实现方式。如果按照代理创建的时期来进行分类：

- 静态代理：由程序员或特定工具自动生成源代码，再对其进行编译。在程序运行之前，代理类的class文件就已经被创建，代理类和委托类的关系在运行前就确定。
- 动态代理：动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定的。

=== 总结

动态代理在大型开发框架中，应用较多并且高效。特别是使用AOP，实现代理模式就更方便了，比如使用Spring AOP和AspectJ这样的工具。 在使用AOP框架时，需要关注几个名词：切面(Aspect)、切入点(JointPoint)
、通知(Advice)、织入(Weave)。

